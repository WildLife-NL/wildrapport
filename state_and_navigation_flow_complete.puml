@startuml
skinparam monochrome true
skinparam padding 2
skinparam nodesep 60
skinparam ranksep 80
skinparam linetype ortho

title State Management & Navigation Architecture

package "Application Entry" {
  class "main.dart" {
    + main()
    --
    Responsibilities:
    * Application initialization
    * Provider setup
    * Environment configuration
    * Initial routing
  }

  class "MultiProvider Setup" {
    + providers: List<Provider>
    --
    Registered Providers:
    * AppStateProvider
    * NavigationStateInterface
    * ScreenStateInterface
    * Other business providers
  }
}

package "State Management" {
  interface ScreenStateInterface {
    + loadScreenState()
    + saveScreenState()
    + updateState()
    + getCurrentState()
    + safeSetState()
  }

  interface NavigationStateInterface {
    + dispose()
    + resetToHome()
    + clearApplicationState()
    + pushAndRemoveUntil()
    + pushReplacementForward()
    + pushReplacementBack()
  }

  class ScreenStateManager {
    - Map<String, dynamic> initialState
    - String screenName
    --
    + loadScreenState()
    + saveScreenState()
    + updateState()
    + getCurrentState()
  }

  class NavigationStateManager {
    - List<TextEditingController> _controllers
    --
    + dispose()
    + resetToHome()
    + clearApplicationState()
    + pushAndRemoveUntil()
  }

  class AppStateProvider {
    - Map<String, dynamic> _globalState
    - Map<String, Map<String, dynamic>> _screenStates
    --
    + getScreenState()
    + setScreenState()
    + resetApplicationState()
  }
}

package "Screen Implementation" {
  class BaseScreen {
    # initState()
    # dispose()
    # build()
  }

  class OverzichtScreen
  class QuestionnaireScreen
  class AnimalsScreen
}

note as ApplicationNote
  <b>Application Architecture Overview</b>

  1. Initialization Flow (main.dart):
     * Load environment configurations
     * Initialize core services
     * Setup provider tree
     * Configure initial route

  2. Provider Structure:
     * AppStateProvider: Global state container
     * NavigationStateInterface: Navigation control
     * ScreenStateInterface: Screen state management
     * Business Logic Providers: Domain-specific state

  3. State Management Layers:
     * Global State: AppStateProvider
     * Screen State: ScreenStateManager
     * Local State: Individual screens
     * Cached State: Persistent storage
end note

note as StateManagementNote
  <b>State Management Flow</b>

  1. Screen Lifecycle:
     * Initialize -> Load saved state
     * Active -> Manage current state
     * Dispose -> Save state if needed

  2. State Updates:
     * Local updates via setState
     * Provider updates for shared state
     * Persistent storage for critical data

  3. Navigation State:
     * Stack management
     * Screen history
     * State preservation
end note

note as NavigationNote
  <b>Navigation Patterns</b>

  1. Standard Navigation:
     * Push/Pop for simple flows
     * State preservation handled automatically

  2. Complex Navigation:
     * Deep linking support
     * State restoration
     * History management

  3. Reset Scenarios:
     * Clear navigation stack
     * Reset application state
     * Handle error conditions
end note

' Relationships
"main.dart" --> "MultiProvider Setup" : configures
"MultiProvider Setup" --> AppStateProvider : provides
"MultiProvider Setup" --> NavigationStateInterface : provides
"MultiProvider Setup" --> ScreenStateInterface : provides

ScreenStateManager ..|> ScreenStateInterface
NavigationStateManager ..|> NavigationStateInterface

BaseScreen --> ScreenStateInterface : implements
BaseScreen --> NavigationStateInterface : uses

OverzichtScreen --|> BaseScreen
QuestionnaireScreen --|> BaseScreen
AnimalsScreen --|> BaseScreen

ScreenStateManager --> AppStateProvider : uses
NavigationStateManager --> AppStateProvider : uses

@enduml